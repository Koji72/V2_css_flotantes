¡El Código me susurra! Siento la vibración de las posibilidades latentes en la arquitectura V2.5. Ir más allá no es solo añadir características, es evolucionar la misma esencia de Universal Scribe. Prepárate para desatar el potencial de una V3.0, forjada en la maestría del código.

Desglosaremos cada punto con la reverencia que merece, revelando los secretos para su implementación.

1. Sistema de Plantillas y Estilos Más Sofisticado (V3.0 - "Chameleon Core")

Concepto: Trascender la simple carga de CSS para ofrecer personalización profunda y accesible.

A. Editor de Temas Visual (GUI):

Desafío: Crear una UI compleja dentro de React que represente visualmente las opciones de estilo y genere CSS válido.

Componentes:

ThemeEditor.tsx: Componente principal que alberga los controles.

ColorPickerInput.tsx: Selector de color que actualiza una variable CSS.

FontSelectorInput.tsx: Desplegable/buscador de fuentes (Google Fonts + fuentes cargadas) que actualiza variables CSS font-family.

StylePreviewPanel.tsx: Un pequeño panel que muestra elementos básicos (cabecera, párrafo, botón, etc.) usando directamente las variables CSS que se están editando para feedback instantáneo.

CssGenerator.ts: Utilidad JS que toma el objeto de estado del tema y genera la cadena CSS final (principalmente las declaraciones :root {}).

Estado (Zustand o Contexto React): Un objeto complejo que almacena los valores actuales del tema:

interface ThemeState {
  name: string;
  variables: {
    [key: `--${string}`]: string; // ej: '--nexus-bg-deep': '#0a0a14'
  };
  // Podría incluir metadata adicional
}


Implementación (Conceptual):

UI: Construir ThemeEditor con subcomponentes para cada tipo de variable (colores, fuentes, espaciado, radios, etc.). Cada control actualiza el objeto ThemeState.

Generación CSS: Cuando el usuario guarda/aplica, CssGenerator toma ThemeState.variables, formatea las variables dentro de un bloque :root { ... } y lo combina con un CSS base estructural (que podría ser fijo o parte de una plantilla "esqueleto").

Aplicación: El CSS generado se pasa a previewManager.applyCustomCSS().

Guardar/Cargar: Lógica para guardar el ThemeState (JSON) en localStorage o exportarlo/importarlo como archivo.

Código (React Componente Simplificado):

// src/components/ThemeEditor.tsx
import React from 'react';
// Asumir un hook useThemeStore() que devuelve { themeState, updateVariable }
import ColorPickerInput from './ColorPickerInput';

function ThemeEditor() {
  const { themeState, updateVariable } = useThemeStore();

  const handleColorChange = (varName: string, value: string) => {
    updateVariable(varName, value);
    // Podrías re-generar y aplicar CSS en tiempo real aquí (costoso)
    // o tener un botón "Aplicar Cambios"
  };

  return (
    <div className="theme-editor-panel">
      <h3>Theme Editor: {themeState.name}</h3>
      <h4>Base Colors</h4>
      {Object.entries(themeState.variables)
        .filter(([key]) => key.includes('-bg-') || key.includes('-text-')) // Filtrar por tipo
        .map(([key, value]) => (
          <ColorPickerInput
            key={key}
            label={key.replace('--', '').replace(/-/g, ' ')}
            variableName={key}
            initialValue={value}
            onChange={handleColorChange}
          />
        ))}
      {/* Añadir selectores de fuentes, inputs numéricos para spacing/radius, etc. */}
      <button onClick={/* lógica para generar y aplicar CSS final */}>
        Apply Theme
      </button>
    </div>
  );
}
export default ThemeEditor;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
TypeScript
IGNORE_WHEN_COPYING_END

B. Variables CSS Expuestas en UI:

Implementación: Similar al Editor de Temas, pero más simple. En lugar de definir toda la estructura, esta UI solo mostraría controles para un conjunto predefinido de variables CSS (ej. --primary-color, --font-size-base) que la plantilla CSS cargada debe respetar y usar. La UI lee los valores actuales del :root del iframe (usando getComputedStyle) y permite al usuario sobreescribirlos (inyectando un <style> adicional con :root { --primary-color: #newvalue !important; } en el iframe).

C. Sistema de Componentes/Bloques Pre-estilizados:

Desafío: Requiere una convención fuerte entre CSS y Markdown.

Markdown: :::component-charcard Personaje Principal | name=Alice | hp=80/100 | status=OK :::

markdownProcessor: Extrae el tipo component-charcard y los atributos (name, hp, status). Genera un HTML específico y bien estructurado para ese componente, usando las clases y data-* correspondientes.

<section class="component component--charcard" data-name="Alice" data-hp="80" data-hp-max="100" data-status="OK">
  <div class="charcard__header">Alice</div>
  <div class="charcard__body">
     <div class="charcard__stat charcard__stat--hp">
        <span class="label">HP:</span> <span class="value">80</span>/<span class="max">100</span>
        <div class="dynamic-progress-bar">...</div>
     </div>
     <div class="charcard__stat charcard__stat--status">
        <span class="label">Status:</span> <span class="value status-indicator status-indicator--ok">OK</span>
     </div>
  </div>
</section>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Html
IGNORE_WHEN_COPYING_END

CSS V2.5: La plantilla debe incluir estilos detallados para .component--charcard, .charcard__header, .charcard__body, .charcard__stat, etc.

2. JavaScript y Mejoras Dinámicas Avanzadas (V3.0 - "Living Preview")

Concepto: Dotar a la vista previa de inteligencia y comportamiento interactivo más allá del CSS.

A. Sistema de Plugins JS:

Desafío: ¡Seguridad y estabilidad! Ejecutar código arbitrario es peligroso. Requiere sandboxing cuidadoso o un sistema de permisos.

Manifiesto de Plugin (JSON):

{
  "name": "Dice Roller Plugin",
  "version": "1.0.0",
  "description": "Adds clickable dice rolls to the preview.",
  "main": "plugin.js", // El archivo JS del plugin
  "permissions": ["dom_read", "dom_write_limited"], // Ejemplo de permisos
  "triggers": ["onContentLoaded", "onClickSelector"], // Cuándo ejecutar
  "targetSelectors": ["[data-dice-roll]"] // A qué elementos afecta
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END

PluginManager.ts:

Carga los manifiestos y los scripts JS de los plugins activados (desde public/plugins/ o gestionados en la UI).

Valida permisos.

Comunicación con Iframe: Usa iframe.contentWindow.postMessage para enviar eventos (ej. contentLoaded, elementClicked) y datos al iframe.

Sandbox en Iframe: Un script "host" dentro del iframe escucha los postMessage, carga el código del plugin (quizás en un Web Worker o un iframe anidado aún más seguro) y le da acceso controlado al DOM según sus permisos.

Plugin plugin.js (Ejemplo Conceptual):

// Escucha mensajes del PluginManager
self.addEventListener('message', (event) => {
  const { type, payload } = event.data;
  if (type === 'onContentLoaded') {
    enhanceDiceRolls(payload.document); // Acceso al document del iframe
  }
  // ... manejar otros eventos ...
});

function enhanceDiceRolls(doc) {
  doc.querySelectorAll('[data-dice-roll]').forEach(el => {
    el.style.cursor = 'pointer';
    el.style.textDecoration = 'underline dotted';
    el.onclick = (e) => {
      const rollExpr = e.target.dataset.diceRoll;
      const result = /* Lógica para tirar dados */;
      e.target.textContent = `${rollExpr} = ${result}`;
      // Opcional: Enviar resultado de vuelta al PluginManager/UI principal
      // self.postMessage({ type: 'diceResult', payload: { roll: rollExpr, result } });
    };
  });
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

B. Widgets Interactivos Integrados:

Tirador de Dados:

Markdown: [[dice:2d6+3]]

markdownProcessor: Genera <span class="interactive-widget widget--dice" data-dice-roll="2d6+3">2d6+3</span>.

previewManager.ts: Añade una función initializeDiceWidgets(doc) que busca .widget--dice, añade un eventListener 'click' que:

Lee data-dice-roll.

Ejecuta la lógica de tirada (necesitarás una pequeña librería o función para parsear y tirar).

Actualiza el textContent del <span> con el resultado.

Añade clases CSS para feedback visual (ej. .rolled).

CSS V2.5: Estilos para .widget--dice y .widget--dice.rolled.

C. Vinculación de Datos Simple (JS):

Desafío: Implementar un mini sistema reactivo dentro del iframe.

Concepto:

Definición: [[var:playerHP=100]] (Define una variable).

Uso: HP: [[bind:playerHP]] / 150 o en un atributo :::statblock | data-current-hp=[[bind:playerHP]] :::.

Modificación: [[button:Take Damage|onclick=setVar('playerHP', getVar('playerHP')-10)]] (Botón que modifica la variable).

markdownProcessor: Detecta [[var:*]] (registra la variable), [[bind:*]] (genera un span/atributo con data-bind="varName"), [[button:*|onclick=*]] (genera un botón con data-onclick-action="...").

previewManager.ts:

Mantiene un objeto previewState = { playerHP: 100, ... }.

Inicializa las variables desde [[var:*]].

Tiene funciones getVar(name) y setVar(name, value).

La función setVar actualiza previewState y luego busca y actualiza todos los elementos con el data-bind correspondiente en el DOM del iframe. También podría volver a ejecutar renderProgressBars si el valor vinculado estaba en un data-value.

Añade listeners a los botones [data-onclick-action] para ejecutar setVar o getVar.

3. Procesamiento de Markdown y Contenido Más Rico (V3.0 - "Universal Parser")

Concepto: Ir más allá del texto y las tablas básicas.

A. Soporte para Embeds:

Markdown: @[youtube](VIDEO_ID_o_URL) , @[map](LAT,LONG) , @[tweet](URL)

markdownProcessor: Detecta @[service](...). Basado en el service, genera el <iframe> o el código de incrustación HTML estándar para ese servicio. Necesita una lista de servicios soportados y sus patrones de URL/ID.

<!-- @[youtube](dQw4w9WgXcQ) -->
<div class="embed-container embed--youtube">
  <iframe src="https://www.youtube.com/embed/dQw4w9WgXcQ" frameborder="0" allowfullscreen></iframe>
</div>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Html
IGNORE_WHEN_COPYING_END

CSS V2.5: Estilos para .embed-container para hacerlo responsivo (aspect ratio).

B. Sintaxis para Diagramas (Mermaid):

Markdown:

:::mermaid
graph TD
    A[Start] --> B{Is it V3?};
    B -- Yes --> C[Awesome!];
    B -- No --> D[Keep Coding!];
    C --> E[Profit!];
    D --> E;
:::
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Markdown
IGNORE_WHEN_COPYING_END

markdownProcessor: Detecta el bloque :::mermaid. Importante: NO procesa el contenido interno como Markdown. Simplemente lo envuelve en <pre class="mermaid"><code>...contenido literal...</code></pre>.

previewManager.ts:

Cargar Librería: Necesita cargar la librería Mermaid.js en el iframe (ya sea añadiendo un tag <script> o usando import si trabajas con módulos dentro del iframe).

Inicializar: Después de que el contenido HTML se haya insertado y Mermaid.js esté cargado, llama a mermaid.initialize({ startOnLoad: false }); y luego mermaid.run({ nodes: doc.querySelectorAll('pre.mermaid code') });. Mermaid encontrará los bloques y los reemplazará con SVGs renderizados.

CSS V2.5: Estilos opcionales para .mermaid svg para ajustar colores/fuentes si Mermaid no los hereda bien o para anular los defaults de Mermaid.

¡El Código fluye! Continuamos desentrañando los secretos para llevar Universal Scribe a su siguiente evolución.

(Continuación...)

4. Mejoras de UI/UX y Flujo de Trabajo (V3.0 - "Command Deck")

Concepto: Hacer que la experiencia de usar Universal Scribe sea más fluida, potente e intuitiva.

A. Gestión Avanzada de Plantillas:

Desafío: Crear una UI dedicada que interactúe con el sistema de carga/aplicación de previewManager.

Componente TemplateManagerUI.tsx:

Muestra una lista de plantillas detectadas (archivos CSS en public/templates/ o las cargadas por el usuario y guardadas en localStorage/indexeDB).

Permite hacer clic en una plantilla para previsualizarla instantáneamente en el panel de vista previa (llamando a previewManager.applyCustomCSS).

Botones para "Activar" (la establece como la plantilla por defecto), "Duplicar" (copia el CSS a un nuevo nombre para editar), "Eliminar", "Exportar".

Quizás una pequeña captura de pantalla o descripción para cada plantilla.

Almacenamiento: Usar localStorage o indexedDB para guardar el CSS de las plantillas cargadas/duplicadas por el usuario, asociándolo a un nombre.

Integración: El botón "Load CSS" podría abrir esta UI en lugar de un simple input de archivo.

B. Gestión de Assets (Imágenes/Fuentes):

Desafío: Requiere almacenamiento (local o backend) y una forma segura de servir los archivos.

Componente AssetManagerUI.tsx:

Permite arrastrar y soltar o seleccionar archivos (imágenes, fuentes).

Muestra miniaturas/listas de los assets subidos.

Genera una URL/identificador único para cada asset (ej., asset://mi-imagen-123.jpg).

Botón "Copiar Enlace Markdown" o "Insertar en Editor".

Almacenamiento:

Opción 1 (Local Simple): Usar indexedDB para guardar los archivos como Blobs. Generar URLs de objeto (URL.createObjectURL(blob)) para usarlas en <img> o @font-face. Desventaja: Las URLs de objeto son temporales y específicas de la sesión/navegador. No es bueno para compartir/exportar.

Opción 2 (Local Persistente): Guardar en indexedDB. Crear un "Service Worker" que intercepte peticiones a asset://* y sirva el Blob correspondiente desde indexedDB. Más complejo pero robusto.

Opción 3 (Backend): Subir los archivos a un servidor/almacenamiento en la nube, que proporciona una URL persistente. Requiere backend y autenticación.

markdownProcessor.ts / CSS: Necesitarían reconocer y manejar las URLs asset://. Si se usa la Opción 2, el navegador las manejaría transparentemente gracias al Service Worker.

C. Configuración Detallada:

Componente SettingsPanel.tsx:

Checkboxes/Switches para activar/desactivar extensiones de marked (GFM, Footnotes, Task Lists, etc.).

Opciones para configurar el comportamiento del parser (ej., ¿permitir HTML crudo?).

Selector para el tema del editor CodeMirror.

Opciones para previewManager (ej., ¿activar sync scroll? ¿delay?).

Gestión de plugins JS (si se implementa).

Estado (Zustand): Guardar estas configuraciones y pasarlas a markdownProcessor y previewManager durante la inicialización o actualización.

5. Capacidades de Colaboración y Compartición (V3.0 - "Scribe Network")

Concepto: Convertir Universal Scribe de una herramienta personal a una plataforma conectada.

A. Exportación a Más Formatos:

HTML Autónomo:

Obtener el HTML renderizado del iframe (iframe.contentWindow.document.documentElement.outerHTML).

Obtener el CSS aplicado (previewManager.currentCSSText).

Obtener los JS necesarios (si hay widgets interactivos).

Combinar todo en un único archivo .html con CSS en <style> y JS en <script>. Requiere limpiar el HTML, manejar URLs relativas/absolutas para assets. Librerías como html-inline podrían ayudar.

ePub: Más complejo. Requiere generar una estructura de archivos específica (XHTML, CSS, metadatos OPF/NCX) y empaquetarla en un .zip (renombrado a .epub). Necesitaría una librería especializada o un proceso de conversión backend.

B. Repositorio/Hub Online:

Desafío: Requiere un backend completo, base de datos, autenticación de usuarios.

Funcionalidad: Plataforma web separada donde los usuarios pueden:

Subir sus archivos .css (Plantillas V2.5/V3.0).

Subir scripts JS (Plugins, si se implementan).

Añadir capturas de pantalla, descripciones, etiquetas.

Buscar, valorar, comentar y descargar plantillas/plugins.

Integración: Universal Scribe podría tener un botón "Buscar Plantillas Online" que abra este Hub o interactúe con su API para mostrar plantillas directamente en la UI de gestión.

C. Colaboración en Tiempo Real:

Desafío: El más complejo. Requiere replantear la arquitectura fundamentalmente.

Tecnologías: WebSockets para comunicación bidireccional, backend para gestionar conexiones y estado del documento, CRDTs (Conflict-free Replicated Data Types) o OT (Operational Transformation) para manejar ediciones concurrentes sin conflictos.

Flujo:

Usuarios se conectan a una "sala" o documento en el servidor.

Las ediciones en el editor Markdown local se envían al servidor (como operaciones de cambio, no el texto completo).

El servidor aplica algoritmos (OT/CRDT) para fusionar los cambios y transmite las operaciones resultantes a todos los demás clientes conectados.

Cada cliente aplica las operaciones recibidas a su copia local del documento Markdown.

La vista previa se actualiza localmente basándose en el Markdown actualizado.

Librerías: Yjs, Automerge son ejemplos populares para CRDTs. CodeMirror tiene extensiones para colaboración.

6. Refinamientos Arquitectónicos (V3.0 - "Core Evolution")

Concepto: Mejorar la estructura interna para mayor mantenibilidad, rendimiento y extensibilidad.

A. markdownProcessor Modular:

markdownProcessor.ts: Se convierte en un orquestador.

src/processing/: Carpeta con módulos:

preprocessRolls.ts

parseMarkdown.ts (llama a marked)

postprocessTables.ts

postprocessInlineData.ts

postprocessLayoutClasses.ts

postprocessStyleClasses.ts

...etc.

Flujo: markdownProcessor.process() llama a cada módulo en secuencia, pasando el estado del HTML (como string o como objeto DOM si se parsea una vez al principio) de uno a otro.

Configuración: Se podría permitir activar/desactivar módulos desde la configuración.

B. Web Components en Preview:

Desafío: Requiere definir y registrar Custom Elements.

Concepto: En lugar de generar HTML simple para un statblock, markdownProcessor genera:

<stat-block data-name="Goblin" data-hp="10" data-hp-max="10" data-ac="12">
  <!-- Quizás contenido adicional como Markdown anidado para acciones -->
</stat-block>


previewManager.ts: Necesita cargar la definición del script para StatBlockComponent extends HTMLElement en el iframe.

StatBlockComponent.js: Define el Shadow DOM del componente (su estructura HTML interna), su CSS encapsulado (usando <style> dentro del Shadow DOM), y su comportamiento JS (ej., un botón para reducir HP).

Ventajas: Encapsulación fuerte (CSS/JS no se filtran), reutilización, semántica mejorada.

Desventajas: Mayor complejidad inicial, el CSS de la plantilla V2.5 no puede estilizar directamente el interior del Shadow DOM (solo el componente <stat-block> en sí o a través de CSS Custom Properties expuestas por el componente).

Conclusión V3.0:

Evolucionar más allá de V2.5 abre un universo de posibilidades. La elección de qué implementar depende de tus objetivos: ¿Más poder para los creadores de contenido (Markdown más rico, widgets)? ¿Más poder para los diseñadores (Editor de Temas)? ¿Más conectividad (Colaboración, Hub)?

Cada paso implica un compromiso significativo de desarrollo. Recomiendo empezar por las mejoras que tengan un impacto más directo en los flujos de trabajo actuales (Gestión de Plantillas/Assets, extensiones Markdown como Mermaid o Footnotes) antes de saltar a cambios arquitectónicos masivos como la Colaboración en Tiempo Real o un Editor de Temas GUI completo.

El Código espera tus órdenes, Maestro. ¡Elige el camino y forjaremos la siguiente era de Universal Scribe!